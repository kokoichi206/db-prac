## sec 1
「豚の耳から絹の財布は作れない」データモデルがうまく設計されていない状態で、「効果的な」SQLを書き始めることはできない。

### 1. 全てのテーブルに主キーを定義する
- 一意
- null にならない
- 安定（変更され得ない）
- 単純

参照整合性、nullではない外部キーを持つ小テーブルのレコードごとに、親テーブルに一致するレコードが含まれていなければならない。

最も単純なのは、RDBMS に応じた、自動生成される値を使うこと。テキストベースの主キー（ConpanyName, email 等）を使うことのメリットは SQL がより単純になる。どちらが良いかいまだに議論されている。


### 2. 冗長なデータを取り除く
正規化を行う。

### 3. 繰り返しグループを取り除く
列は高くつく
行は安上がりである

### 4. 列ごとにプロパティを１つ
AuthFirst, AuthMid, AuthLast, AuthCity, AuthStreet, AuthStNum...

``` sql
SELECT AuthorID AS AuthID,
    CONCAT(AuthFirst,
        CASE WHEN AuthMid IS NULL
            THEN ' '
            ELSE CONCAT(' ', AuthMid, ' ')
            END, AuthLast) AS AuthName,
    CONCAT(AuthStNum, ' ', AuthStreet, ' ',
        AuthCity, ', ', ...) AS AuthAddress
FROM Authors;
```

- 検索やグループ化が簡単になる
- どうフィルタリングするかによってデータの粒度が決まる
- 元に戻すには CONCAT を利用する

### 5. 計算値の格納は一般に避ける！
DB のシステムとして計算列を定義できることが多いが、パフォーマンスに悪影響！

### 6. 参照整合性を確保するための外部キー
スキーマを正しく設計すると、テーブルの多くに外部キーが定義される。これらの外部キーには、親テーブルの主キーの値が含まれている。

### 7. テーブル間の関係
今扱ってるのは、構造化データ？それとも半構造化データ？

XML, JSON のような半構造化データに対しては RDB は不向きすぎる。

- 同じような列を含んでいるようにみえるテーブルを結合する意味が本当にあるのか？

### 8. Beyond 3NF
3NF をみたいしている設計が、より上のレベルの正規形に反する可能性があるのは、１つのテーブルが複数のテーブルに関連している時。特に、テーブルが１対他になっていて、そうした関係が１つではない場合。

最初の３つの正規形は、リレーション属性のうち**関数従属性**に関するものである。つまり、その属性がリレーションのキーに依存すること意味する。たとえば、電話番号 xxx-xxx-xxxx を格納している列はその持ち主の John Doe を格納している列に関数従属している、と言える

第四正規形（4NF）は、多値従属性に関係している。２つの属性が互いに独立しているものの、リレーションの同じキーに依存している、というケース

情報無損失分析のテスト

### 9. データウェアハウスでは非正規形
正規化を行うと、データが一箇所に配置されるため更新や挿入が高速になる、データが重複しないため、負荷の高い Group By や Distinct クエリが必要になることもない。RDB で正規化した方が良い理由、それは、アプリケーションが書き込み主体であるため、書き込みの負荷が読み取りの負荷を上回るためである。

正規化されたテーブルの問題点は、テーブル間の結合の数が増えるほど、オプティマイザが効率的な実行プランを見つけるのが難しくなること。データウェアハウスでは、SELECT を高速にするため、非正規化されたデータベースが適している。

書き込みは滅多に発生しないため、インデックスの数が多すぎるために書き込みのパフォーマンスが劇的に低下する、という心配もない。

- 計算値や派生値を格納することも、非正規化の手法の１つ


## sec 2
SQL テーブルをうまく動作させるための主な要素の１つは、テーブルを正しくインデックス付けすること。

### 10. インデックスを作成するときの null の扱い

### 11. データスキャンを最小限に抑える
- インデックスシーク
    - 必要な値が全部インデックスに含まれる
- インデックススキャン
- テーブルスキャン

多くのインデックスは、データ取得の高速化には貢献せず、それどころか更新を低速化させることがあるのを覚えておく。

DBMS で使用されている最も一般的な種類のインデックスは B-tree。

- B-tree
    - クラスタ化インデックス
    - 非クラスタ化インデックス

インデックスが意味を持つのは、テーブルが大きい場合だけ。ほとんどのデータベースエンジンは、テーブルが小さい場合はメモリに読み込んでしまう。


### 12. フィルタリング以外でのインデックス
インデックスは、データ構造とは別物であり、それ専用のディスク容量が必要となる。

b-tree いんでくっすについては、データの**順序付き表現**となっているため、ソートがえぐい。一般にソートは、データを一時的にバッファに格納する必要があるためえぐい。

- WHERE 句に含まれている列がインデックスに含まれているかどうかは、クエリのパフォーマンスに影響を与える

### 13. トリガを使いすぎない
DRI（Declarative Referential Integrity）を使う方が一般に良い

``` sql
ALTER TABLE Order_Details
    ADD CONSTRAINT fkOrder FOREIGN KEY (OrderNumber)
        REFERENCES Orders (OrderNumber) ON DELETE CASCADE;
```

### 14. サブセットの取捨選択にフィルター選択されたインデックス

### 15. 宣言型の制約
- NOT NULL
- UNIQUE KEY
    - PRIMARY と異なり null 値を入力できる
- PRIMARY KEY
    - テーブルに１つのみ
- FOREIGN KEY
- CHECK
    - フィールドまたはテーブルで定義可能
    - 指定した値のみを格納できるようになる
- DEFAULT

ビジネスルールを適応することとデータの関係を維持することはデータモデルの一部であり、その実行責任はアプリケーションではなくデータベースにある！！

クエリオプティマイザ

### 16. SQLダイアレクト
- null
    - 2つのnull値の順序は等しいとみなされる。
    - null値をソートした時の順序は、null以外のすべての値の前または後ろにすべきである。
        - どっちかはRDBMSによる！
- 結果セットの制限
    - FETCH FIRST
    - ウィンドウ関数
    - カーソル
- BOOLEAN (SQLの規格)
    - TRUE
    - FALSE
    - UNKNOWN または NULL
- 常に DBMS のマニュアルを調べる！

### 17. 計算値をインデックスで使用する？
``` sql
SELECT EmployeeID, EmpFirstName, EmpLastName
FROM Employees
WHERE UPPER(EmpLastName) = 'John';
```

これだとインデックスが効かない！！
そこで次のようにするう

``` sql
CREATE INDEX EmpLastNameUpper
    ON Employees (UPPER(EmpLastName))



