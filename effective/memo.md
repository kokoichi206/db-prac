## sec 1
「豚の耳から絹の財布は作れない」データモデルがうまく設計されていない状態で、「効果的な」SQLを書き始めることはできない。

### 1. 全てのテーブルに主キーを定義する
- 一意
- null にならない
- 安定（変更され得ない）
- 単純

参照整合性、nullではない外部キーを持つ小テーブルのレコードごとに、親テーブルに一致するレコードが含まれていなければならない。

最も単純なのは、RDBMS に応じた、自動生成される値を使うこと。テキストベースの主キー（ConpanyName, email 等）を使うことのメリットは SQL がより単純になる。どちらが良いかいまだに議論されている。


### 2. 冗長なデータを取り除く
正規化を行う。

### 3. 繰り返しグループを取り除く
列は高くつく
行は安上がりである

### 4. 列ごとにプロパティを１つ
AuthFirst, AuthMid, AuthLast, AuthCity, AuthStreet, AuthStNum...

``` sql
SELECT AuthorID AS AuthID,
    CONCAT(AuthFirst,
        CASE WHEN AuthMid IS NULL
            THEN ' '
            ELSE CONCAT(' ', AuthMid, ' ')
            END, AuthLast) AS AuthName,
    CONCAT(AuthStNum, ' ', AuthStreet, ' ',
        AuthCity, ', ', ...) AS AuthAddress
FROM Authors;
```

- 検索やグループ化が簡単になる
- どうフィルタリングするかによってデータの粒度が決まる
- 元に戻すには CONCAT を利用する

### 5. 計算値の格納は一般に避ける！
DB のシステムとして計算列を定義できることが多いが、パフォーマンスに悪影響！

### 6. 参照整合性を確保するための外部キー
スキーマを正しく設計すると、テーブルの多くに外部キーが定義される。これらの外部キーには、親テーブルの主キーの値が含まれている。

### 7. テーブル間の関係
今扱ってるのは、構造化データ？それとも半構造化データ？

XML, JSON のような半構造化データに対しては RDB は不向きすぎる。

- 同じような列を含んでいるようにみえるテーブルを結合する意味が本当にあるのか？

### 8. Beyond 3NF
3NF をみたいしている設計が、より上のレベルの正規形に反する可能性があるのは、１つのテーブルが複数のテーブルに関連している時。特に、テーブルが１対他になっていて、そうした関係が１つではない場合。

最初の３つの正規形は、リレーション属性のうち**関数従属性**に関するものである。つまり、その属性がリレーションのキーに依存すること意味する。たとえば、電話番号 xxx-xxx-xxxx を格納している列はその持ち主の John Doe を格納している列に関数従属している、と言える

第四正規形（4NF）は、多値従属性に関係している。２つの属性が互いに独立しているものの、リレーションの同じキーに依存している、というケース

情報無損失分析のテスト

### 9. データウェアハウスでは非正規形
正規化を行うと、データが一箇所に配置されるため更新や挿入が高速になる、データが重複しないため、負荷の高い Group By や Distinct クエリが必要になることもない。RDB で正規化した方が良い理由、それは、アプリケーションが書き込み主体であるため、書き込みの負荷が読み取りの負荷を上回るためである。

正規化されたテーブルの問題点は、テーブル間の結合の数が増えるほど、オプティマイザが効率的な実行プランを見つけるのが難しくなること。データウェアハウスでは、SELECT を高速にするため、非正規化されたデータベースが適している。

書き込みは滅多に発生しないため、インデックスの数が多すぎるために書き込みのパフォーマンスが劇的に低下する、という心配もない。

- 計算値や派生値を格納することも、非正規化の手法の１つ




